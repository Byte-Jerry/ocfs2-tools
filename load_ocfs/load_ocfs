#!/bin/sh

#
# This is a smart module loader.  The main loading engine should work
# untouched.
#
# A parameter for the module must be listed in the
# VALID_PARMS shell variable.  This variable is a colon-separated list
# of the valid module parameters.  Parameters that are required
# must also be listed in the REQUIRED_PARMS shell variable.  This is
# also a colon-separated list.
#
# This script now supports multiple versions of a module.  Often, one
# version of the module will support a parameter that another version
# does not.  The union of all possible parameters should be in the
# VALID_PARMS list.  Each module version should specify the appropriate
# subset in the USED_PARMS list.  The USED_PARMS list should contain
# at least the REQUIRED_PARMS list.  It then adds any parameters shared
# between modules and any parameters unique to this version of the
# module.  This allows the configuration file to support multiple
# module versions, ignoring the parameters for a version of the module
# not in this use.
#
# Validation of parameter values can also be done.  If a shell function
# of the name validate_<variable_name> exists, it will be run with the
# parameter value as its only argument.  If it fails, module loading
# will fail.
#
# Copyright (C) 2002 Oracle Corporation.  All rights reserved.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have recieved a copy of the GNU General Public
# License along with this program; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 021110-1307, USA.
#
# Author: Joel Becker <joel.becker@oracle.com>
#

#
##################################################################
#
# Edit MODULE and CONFIG to specify the module name and the
# configuration file location.
#
# Edit VALID_PARMS and REQUIRED_PARMS to specify the parameters
# allowed and required.  Also, add any validation functions needed.
#
# If there are multiple versions of the module, set the USED_PARMS list
# for each version.  Also, use the load_* switch to choose the module
# name and which USED_PARMS list to use.
#

# Force LC_ALL=C for proper ifconfig(8) parsing
export LC_ALL=C

# Path to configuration file
CONFIG=/etc/ocfs.conf

# Set VALID_PARMS to the untion of all parameters valid for the modules
# this script suppports.  Set REQUIRED_PARMS to the parameters requred
# by all the modules this script supports.
COMMON_PARMS="node_name:node_number:debug_context:debug_level:ip_address:guid"
VALID_PARMS="$COMMON_PARMS:ip_port:ip_port_v2:comm_voting"
REQUIRED_PARMS="node_name:ip_address:guid"

# Multi-module switch.  The script's argv0 is used to determine the
# module name.  Do not modify these lines.  Edit MODULE down where it
# says to.
MODULE_SCRIPT="`basename $0`"
MODULE="${MODULE_SCRIPT#load_}"
case "$MODULE" in
ocfs2)
    REQUIRED_PARMS="$REQUIRED_PARMS:ip_port_v2"
    USED_PARMS="$COMMON_PARMS:ip_port_v2"
    ;;
ocfs)
    REQUIRED_PARMS="$REQUIRED_PARMS:ip_port"
    USED_PARMS="$COMMON_PARMS:ip_port:comm_voting"
    ;;
esac

# If you must hardcode an absolute module path for testing, do it HERE.
# MODULE=/path/to/test/module/ocfsX.o

# Helper function for IP addresses
check_ip()
{
    ADDR="$1"
    case "$ADDR" in
    *[^0-9.]*)
        ;;
    *)
        R=${ADDR}
        IP0=${R%%.*}
        R=${R#*.}
        IP1=${R%%.*}
        R=${R#*.}
        IP2=${R%%.*}
        R=${R#*.}
        IP3=$R
        if [ -n "$IP0" -a -n "$IP1" -a -n "$IP2" -a -n "$IP3" ]
        then
            if [ "$IP0" -gt -1 -a "$IP0" -lt 256 -a \
                 "$IP1" -gt -1 -a "$IP1" -lt 256 -a \
                 "$IP2" -gt -1 -a "$IP2" -lt 256 -a \
                 "$IP3" -gt -1 -a "$IP3" -lt 256 ]
            then
                return 0
            fi
        fi
        ;;
    esac
    
    log "IP address \"$ADDR\" is invalid"
    return 1
}

# Helper function to verify an address is associated with an interface
check_ifconfig()
{
    ADDR="$1"
    IFCONFIG="`ifconfig 2>/dev/null`"
    if [ "$?" != 0 ]
    then
        log "Unable to run ifconfig"
        return 1
    fi

    case "$IFCONFIG" in
    *addr:"$ADDR"[\ \	]*)
        return 0
        ;;
    *)
        ;;
    esac

    log "IP address \"$ADDR\" is not associated with an interface"
    return 1
}

# Validate the ip_address module parameter
validate_ip_address()
{
    ADDR="$1"

    if ! check_ip "$ADDR"
    then
        return 1
    fi
    if ! check_ifconfig "$ADDR"
    then
        return 1
    fi

    return 0
}

# Validate the ip_port module parameter
validate_ip_port()
{
    PORT="$1"

    case "$PORT" in
    *[^0-9]*)
        return 1
        ;;
    *)
        ;;
    esac

    return 0
}

# Validate the node_number module parameter
validate_node_number()
{
    NUM="$1"

    case "$NUM" in
    *[^0-9]*)
        ;;
    *)
        if [ "$NUM" -gt -1 -o "$NUM" -lt 32 ]
        then
            return 0
        fi
        ;;
    esac

    log "Invalid node number: \"$NUM\""
    return 1
}

# Validate the guid against the MAC address.  This depends on the IP
validate_guid()
{
    GUID="`echo \"$1\" | tr \"a-z\" \"A-Z\"`"

    if [ "`expr length "$GUID"`" != "32" ]
    then
        log "The GUID is not 32 characters"
        return 1
    fi

    if [ -z "$ip_address" ]
    then
        log "No IP address is in the ocfs.conf file.  Please create
	a correct configuration file."
        return 1
    fi

    if ! check_ip "$ADDR"
    then
        log "The IP address is invalid."
        return 1
    fi

    CUR_MAC=""
    RES_MAC=`ifconfig 2>/dev/null | while read -r LINE
    do
        case "$LINE" in
        *HWaddr\ *)
            CUR_MAC="${LINE##*HWaddr }"
            ;;
        *\ addr:"$ip_address"\ *)
            if [ -n "$CUR_MAC" ]
            then
                echo "$CUR_MAC" | sed -e 's/://g' | tr "a-z" "A-Z"
                return 0
            fi
            ;;
        "")
            CUR_MAC=""
            ;;
        *)
            ;;
        esac
    done`

    if [ -z "$RES_MAC" ]
    then
        log "There is no active interface for the IP address $ip_address"
        return 1
    fi

    if [ "${GUID%$RES_MAC}" = "$GUID" ]
    then
        log "The GUID does not match the current MAC address for $ip_address.
	If this is a new node, please run 'ocfs_uid_gen -c' to create
	a new GUID for this node.  If this node already belongs to a
	filesystem and the MAC address of the machine has changed,
	please run 'ocfs_uid_gen -r'."
        return 1
    fi

    # Here we hack in the cs value for the OCFS module.  Note
    # That this is in module-specific validate_* code, not the
    # generic engine

    GC="${GUID}"

    CS=0
    while expr length "$GC" >/dev/null 2>&1
    do
        LETTER="`expr substr "$GC" 1 1 2>/dev/null`" 
        GC="${GC#$LETTER}"
        case "$LETTER" in
        [0-9])
            CS="`expr "$CS" + "$LETTER" + 48`"
            ;;
        A)
            CS="`expr "$CS" + 65`"
            ;;
        B)
            CS="`expr "$CS" + 66`"
            ;;
        C)
            CS="`expr "$CS" + 67`"
            ;;
        D)
            CS="`expr "$CS" + 68`"
            ;;
        E)
            CS="`expr "$CS" + 69`"
            ;;
        F)
            CS="`expr "$CS" + 70`"
            ;;
        *)
            log "Invalid character in GUID: \"$LETTER\""
            return 1
            ;;
        esac
    done

    # This is the real hack, modifying INSMOD
    INSMOD="$INSMOD cs=\"$CS\""

    # Hack #2, modifying $guid for uppercase
    guid="$GUID"

    return 0
}


#
##################################################################
#
# Below here is the generic engine.  This code should not change.
#

# Check on insmod
INSMOD="/sbin/insmod"
if [ ! -x $INSMOD ]
then
	die "/sbin/insmod does not exist"
fi
INSMOD="$INSMOD $MODULE"

log()
{
    echo "load_ocfs: $@" >&2
}

die()
{
    log "$@"
    exit 1
}

lead_strip()
{
    LINE="$@"
    NEWLINE="${LINE# }"
    while [ "$LINE" != "$NEWLINE" ]
    do
        LINE="$NEWLINE"
        NEWLINE="${LINE# }"
    done

    echo "$LINE"
}

tail_strip()
{
    LINE="$@"
    NEWLINE="${LINE% }"
    while [ "$LINE" != "$NEWLINE" ]
    do
        LINE="$NEWLINE"
        NEWLINE="${LINE% }"
    done

    echo "$LINE"
}


# Validate the valid parameter list
case "$VALID_PARMS" in
*[\ /-]*)
    die "Module parameter list is invalid: \"$VALID_PARMS\""
    ;;
*)
    ;;
esac

# Validate the required parameter list
TREQ="$REQUIRED_PARMS"
while [ -n "$TREQ" ]
do
    TPARM="${TREQ%%:*}"
    TREQ="${TREQ#*:}"
    if [ "$TREQ" = "$TPARM" ]
    then
        TREQ=""
    fi

    case "$VALID_PARMS" in
    *:"$TPARM":*|*:"$TPARM"|"$TPARM":*|"$TPARM")
        ;;
    *)
        die "Required parameter \"$TPARM\" is not in VALID_PARMS"
        ;;
    esac
done

# Validate the used parameter list.  Yes, this repeats required ones.
TUSE="$USED_PARMS"
while [ -n "$TUSE" ]
do
    TPARM="${TUSE%%:*}"
    TUSE="${TUSE#*:}"
    if [ "$TUSE" = "$TPARM" ]
    then
        TUSE=""
    fi

    case "$VALID_PARMS" in
    *:"$TPARM":*|*:"$TPARM"|"$TPARM":*|"$TPARM")
        ;;
    *)
        die "Used parameter \"$TPARM\" is not in VALID_PARMS"
        ;;
    esac
done

# Do a quick validation of the command line arguments
# Actually using the values comes later.
for ORIGARG in "$@"
do
    ARG="`lead_strip "$ORIGARG"`"
    case "$ARG" in
    *=*)
        PARM="`tail_strip "${ARG%%=*}"`"
        case "$VALID_PARMS" in
        *:"$PARM":*|*:"$PARM"|"$PARM":*|"$PARM")
            ;;
        *)
            die "Unknown module parameter in argument: \"$ORIGARG\""
            ;;
        esac
        ;;
    *)
        die "Invalid argument: \"$ORIGARG\""
        ;;
    esac
done

# Read config file
while read -r RAWLINE
do
    LINE="`lead_strip "$RAWLINE"`"
    LINE="`tail_strip "$LINE"`"
    case "$LINE" in
    \#*)
        ;;
    "")
        ;;
    *=*)
        PARM="`tail_strip "${LINE%%=*}"`"
        VALUE="`lead_strip "${LINE#*=}"`"
        if [ -z "$PARM" ]
        then
            die "Invalid config line: \"$RAWLINE\""
        fi
        if [ -z "$VALUE" ]
        then
            continue
        fi
        case "$PARM" in
        *[\ :/-]*)
            die "Invalid module parameter name: \"$PARM\""
            ;;
        *)
            ;;
        esac
        case "$VALID_PARMS" in
        *:"$PARM":*|*:"$PARM"|"$PARM":*|"$PARM")
            eval EARVAL=\""\$$PARM"\"
            if [ -n "$EARVAL" ]
            then
                die "Module parameter \"$PARM\" is in the configuration file twice"
            fi
            eval $PARM=\""$VALUE"\"
            ;;
        *)
            die "Unknown module parameter: \"$PARM\""
            ;;
        esac
        ;;
    *)
        die "Invalid config line: \"$RAWLINE\""
        ;;
    esac
done < "$CONFIG"

# Now we actually use the arguments
# It's after the config read to override configuration bits
for ORIGARG in "$@"
do
    ARG="`lead_strip "$ORIGARG"`"
    ARG="`tail_strip "$ARG"`"
    case "$ARG" in
    *=*)
        PARM="`tail_strip "${ARG%%=*}"`"
        VALUE="`lead_strip "${ARG#*=}"`"
        # We checked the parameter's validity above
        eval $PARM=\""$VALUE"\"
        ;;
    *)
        die "Broken script: Invalid argument: \"$ORIGARG\""
        ;;
    esac
done

# Run the validate functions on the parameters.  This must happen
# after all values have been loaded.
TVALID="$VALID_PARMS"
while [ -n "$TVALID" ]
do
    TPARM="${TVALID%%:*}"
    TVALID="${TVALID#*:}"
    if [ "$TVALID" = "$TPARM" ]
    then
        TVALID=""
    fi
    if [ -n "$TPARM" ]
    then
        eval VALUE=\""\$$TPARM"\"
        if [ -n "$VALUE" ]
        then
            TYPE="`type "validate_$TPARM" 2>/dev/null | head -1`"
            case "$TYPE" in
            *\ function)
                eval "validate_$TPARM" \""$VALUE"\"
                if [ "$?" != 0 ]
                then
                    die "Parameter \"$TPARM\" is invalid"
                fi
                ;;
            *)
                ;;
            esac
            # Ignore parameters not in the USED list
            case "$USED_PARMS" in
            *:"$TPARM":*|*:"$TPARM"|"$TPARM":*|"$TPARM")
                INSMOD="$INSMOD $TPARM=\"$VALUE\""
                ;;
            *)
                ;;
            esac
        fi
    fi
done

# Check for all required parameters
TREQ="$REQUIRED_PARMS"
while [ -n "$TREQ" ]
do
    TPARM="${TREQ%%:*}"
    TREQ="${TREQ#*:}"
    if [ "$TREQ" = "$TPARM" ]
    then
        TREQ=""
    fi

    case "$INSMOD" in
    *" $TPARM="*)
        ;;
    *)
        die "Required parameter \"$TPARM\" was not specified"
        ;;
    esac
done

sh -c "echo $INSMOD"
sh -c "$INSMOD"
if [ "$?" != 0 ]
then
    die "insmod failed"
fi


